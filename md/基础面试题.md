

## HTML&CSS

### 行内元素和块级元素都有哪一些？

> display:block/table;有divh1h2 table ul ol p等
> display:inline/inline-block;span img input button

- 行内元素

```html
```

- 行内块元素

```html
```

- 块级元素

```html
```



### html语义化

> ◆让人更容易读懂（增加代码可读性）
> ◆让搜索引擎更容易读懂(SEO)
>
> 举个例子

### margin纵向重叠问题

相邻元素的margin-top和margin-bottom会发生重叠
空白内容的<p></p>也会重叠



### BFC概念

> BFC 即 Block Formatting Contexts (块级格式化上下文)
>
> BFC元素特性表现原则就是，内部子元素不会影响外部的元素
>
> 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。

> BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。他是流体特性：像div这种块状水平元素，在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。

只要元素满足下面任一条件即可触发 BFC 特性：

- body 根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)



### 什么是弹性布局

解决某元素中“`子元素`”的布局方式，为布局提供最大的灵活性。

设为 `flex` 布局以后，子元素的 `float、clear` 和`vertical-align`属性将失效!!!

`display:flex`; 属性`align-self` 定义子元素的位置。

[什么是弹性布局？弹性布局的具体使用方法 - 简书 (jianshu.com)](https://www.jianshu.com/p/f91389e0d1d2)

[(6条消息) 弹性布局介绍_一念花开丶君临天下的博客-CSDN博客_什么是弹性布局](https://blog.csdn.net/qq_43431024/article/details/100766477)



### （掌握）html5有哪些新特性？

- (1)`Canvas绘图`
- (2)`SVG绘图`
- (3)`地理定位`
- (4)`Web Worker`
- `web worker` 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。
- (5)`Web Storage`
- 1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）
- 2.（兼容性差,数据8MB,操作简单）sessionStorage
- 3.localStorage
- (6)`Web Socket`
- WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。

### 1rem、1em、vw/vh、1px 各自的含义

1. 1rem ；长度单位相对于根元素 html,通常个 html 元素设置一个字体大小 find-size,其他根元素单位就为 rem

2. 1em:

   子元素字体大 小的 em 是相对于父元素字体大小

   元素的width/height/padding/margin 用 em 的话是相对该元素的 fond-size

3. vw/vh :
   全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。

4. 1px :
   px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的，一般电脑的分辨率有{1920 * 1024}等不同的分辨率，1920 * 1024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素

5. 浏览器默认字体大小是16px,1rem就是16px.

1rem= 1em= 16px
1em= 16px
1MB= 1040K



### 单页面应用

我理解的单页面应用就是说不刷新，整个的交互过程是通过操作盒子的显示和隐藏并且结合ajax去实现的（局部更新）

优点：

- 页面无刷新，用户体验良好
- 前后端分离

缺点：

- 首屏加载过慢
- SEO不友好

拓展：多页面应用（MPA）

每一个页面都是一个完整的页面，页面之间的跳转是从一个页面到另一个页面，



![20200508154734163](images/20200508154734163.png)

[(8条消息) 浅谈前端SPA（单页面应用）_huangpb0624的博客-CSDN博客_前端spa](https://blog.csdn.net/huangpb123/article/details/86183453)****



### 重排和重绘

> 重绘：当一个元素的外观发生改变(元素的填充颜色，改变visibility，outline，background等属性)，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。

> 重排：当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。耗性能尽量避免
>
> - DOM元素的几何属性变化
> - 页面初始渲染，这是开销最大的一次重排
> - 添加/删除可见的DOM元素
> - 改变元素位置
> - 改变元素尺寸，比如边距、填充、边框、宽度和高度等
> - 改变元素内容，比如文字数量，图片大小等
> - 改变元素字体大小
> - 改变浏览器窗口尺寸，比如resize事件发生时

两者的区别

**重绘不一定导致重排，但重排一定会导致重绘**。

- 重绘不会带来重新布局，并不一定伴随着重排。
- 在实践中，应该尽量减少重排次数和缩小重排的影响范围。有以下几种方法：
- [ ] 将多次改变样式属性的操作合并成一次操作
- [ ] 将需要多次重排的元素，position属性设为absolute或fixed，使其脱离文档流，这样它的变化就不会影响到其他元素
- [ ] 在内存中多次操作节点，完成后再添加到文档中去
- [ ] 如果要对一个元素进行复杂的操作，可以将其display属性设置为none使其隐藏，待操作完成后再显示
- [ ] 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量



### 页面生成的过程：

1.HTML 被 HTML 解析器解析成 DOM 树；

2.CSS  被 CSS 解析器解析成 CSSOM 树；

3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；

4.生成布局(Layout)，也就是为每个节点分配一个应出现在屏幕上的确切坐标

5.将布局绘制(paint)在屏幕上，遍历渲染树，显示出整个页面。

第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/6/170af501e710ce67~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

渲染：

在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。


作者：齐小神
链接：https://juejin.cn/post/6844904083212468238
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 如何实现浏览器内多个标签页之间的通讯

[(8条消息) 实现浏览器内多个标签页面之间通信的四种方法_Love——金哥哥的博客-CSDN博客_浏览器多个标签页之间的通信](https://blog.csdn.net/weixin_46399753/article/details/105211771)



### 解释css sprites ，如何使用？

SS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。

CSS Sprites为一些大型的网站节约了带宽，让提高了用户的加载速度和用户体验，不需要加载更多的图片



作者：小李不小
链接：https://www.jianshu.com/p/96b995102817
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 伪类和伪元素的区别

| 新增伪类              | 作用                                             |
| --------------------- | ------------------------------------------------ |
| p:first-of-type       | 选择属于其父元素的首个<p>元素的每个<p>元素。     |
| p:last-of-type        | 选择属于其父元素的最后<p>元素的每个<p>元素。     |
| p:only-of-type        | 选择属于其父元素唯一的<p>元素的每个<p>元素。     |
| p:only-child          | 选择属于其父元素唯一的子元素的每个<p>元素。      |
| p:nth-child(n)        | 选择属于其父元素的第n个子元素的每个<p>元素。     |
| p:nth-last-child(n)   | 选择属于其父元素的倒数第n个子元素的每个<p>元素。 |
| p:nth-of-type(n)      | 选择属于其父元素第n个<p>元素的每个<p>元素。      |
| p:nth-last-of-type(n) | 选择属于其父元素倒数第n个<p>元素的每个<p>元素。  |
| p:last-child          | 选择属于其父元素最后一个子元素的每个<p>元素。    |
| p:empty               | 选择没有子元素的每个<p>元素（包括文本节点）。    |
| p:target              | 选择当前活动的<p>元素。                          |
| :not(p)               | 选择非<p>元素的每个元素。                        |
| :enabled              | 控制表单控件的可用状态。                         |
| :disabled             | 控制表单控件的禁用状态。                         |
| :checked              | 单选框或复选框被选中。                           |

| 伪类         | 作用                           |
| ------------ | ------------------------------ |
| :hover       | 将样式添加到鼠标悬浮的元素     |
| :active      | 将样式添加到被激活的元素       |
| :focus       | 将样式添加到获得焦点的元素     |
| :link        | 将样式添加到未被访问过的链接   |
| :visited     | 将样式添加到被访问过的链接     |
| :first-child | 将样式添加到元素的第一个子元素 |
| :lang        | 定义指定的元素中使用的语言     |

![image-20220726214639146](images/image-20220726214639146.png)



## JS

### JavaScript：解释型语言和编译型语言

计算机不能直接理解任何除机器语言以外的语言，所以必须把程序员所写的程序翻译成机器语言才能执行程序。程序语言被翻译成机器语言的工具，被称为翻译器。

- 翻译器翻译的方式有两种：编译 、 解释，区别在于翻译的时间点不同
- 编译器在代码执行之前进行编译，生成中间代码文件
- 解释器是在运行时进行及时解释，并立即执行。

<img src="https://cdn.jsdelivr.net/gh/Pu-feng/mdimages/202207181904312.png"/>

怎么运行的

使用js解析器，解析才能运行

[JavaScript是如何运行的(上) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/93922328)



### JavaScript 中的数组和函数在内存中是如何存储的？

#### 数据结构

在计算机科学中，数据结构（英语：data structure）是计算机中存储、组织数据的方式。

常见的有：堆栈，队列，数组，链表，树，图，堆积，散列表

#### js中的数据类型

> 基本数据结构

保存在栈内存中，在内存中是占有固定大小的。

基本数据类型：Number、String、Boolean、Undefined、Null、Symbol

> 引用数据类型

引用数据类型是不固定大小的数据，地址保存在栈中，值则是保存到堆中。

引用数据类型：Object、Array、Function

所以函数和数组的地址是保存在栈中的，值是保存在堆中的。



### Promise、async、await相关

Promise是种异步编程的解决方案，它可以把异步代码写成看起来像同步代码，可以用来解决回调地狱（回调函数多层嵌套）。

Promise本质上是个内置构造函数，Promise的三个状态：pending：初始状态，悬浮未决的；fulfilled：成功状态；rejected：失败状态。状态一旦确定就不会改变

Promise的基本语法：

```js
// 默认pending: 初始状态
var p = new Promise(function (resolve,reject) {
    if("操作成功"){
        resolve();//pending-->fulfilled  异步操作成功的回调函数
    }else{
        reject(); //pending-->reject     异步操作失败的回调函数
    }
})
p.then(data => {//在外面调用then处理成功的逻辑
    console.log("处理成功的逻辑");//fulfilled 
}).catch(err=>{//在外面调用catch处理失败的逻辑
    console.log("失败的逻辑");//reject
})
// then方法会在异步成功后调用，catch方法会在异步失败后调用

then正常返回resolved，里面有报错则返回rejected
catch正常返回也会resolved，里面有报错则返回rejected
```



async返回值是promise对象，而then传过来的参数就是return后面的值

```js
// async写法
async function fun(){
    return 1
}
// promise写法 相当于跟上面代码一样
function fun1(){
    return new Promise((resolve,reject)=>{
        resolve(1);
    })
}
// 直接调用会输出promise对象
fun(); // Promise {<fulfilled>: 1}

fun().then(res=>{
    console.log(res); // 1
})

```

![image-20220705153727701](images/image-20220705153727701.png)

async的常用

```js
// 异步代码像是同步代码
let p1 = new Promise((resolve)=>{
    resolve(1)
})
let p2 = new Promise((resolve)=>{
    resolve(2)
})

async function fun(){
    // 相当于await后面加一个promise对象，然后可以直接拿到promise对象的resolve传的值
    let a = await p1;
    let b = await p2;
    console.log(a); // then中执行的代码
    console.log(b);
}
fun(); // 1 2
```

[JS中的async/await的用法和理解 - 曼施坦因 - 博客园 (cnblogs.com)](https://www.cnblogs.com/liquanjiang/p/11409792.html)



参考：[(6条消息) 带你了解事件循环机制(Event Loop)_**Crazy的博客-CSDN博客_事件循环机制](https://blog.csdn.net/weixin_52092151/article/details/119788483)

[(6条消息) 面试题：说说事件循环机制(满分答案来了)_winty~~的博客-CSDN博客](https://blog.csdn.net/LuckyWinty/article/details/104765786?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-104765786-blog-119788483.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-104765786-blog-119788483.pc_relevant_default&utm_relevant_index=2)



### 前端怎么压缩图片

input 读取到 文件 ，使用 FileReader 将其转换为 base64 编码

新建 img ，使其 src 指向刚刚的 base64

新建 canvas ，将 img 画到 canvas 上

利用 canvas.toDataURL/toBlob 将 canvas 导出为 base64 或 Blob

将 base64 或 Blob 转化为 File

作者：凉城a
链接：https://juejin.cn/post/6940430496128040967
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。****

[前端实现图片压缩及遇到的问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143873360)



### 模块化规范

[前端模块化——彻底搞懂AMD、CMD、ESM和CommonJS - 奔跑的瓜牛 - 博客园 (cnblogs.com)](https://www.cnblogs.com/chenwenhao/p/12153332.html#:~:text=AMD%2FCMD区,要的时候才执行。)



### 那些操作会造成内存泄漏？

>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
>通俗点就是指由于疏忽或者错误造成程序未能释放已经不再使用的内存，不再用到的内存却没有及时释放，从而造成内存上的浪费。

1. 闭包

闭包可以维持函数内局部变量，使其得不到释放。如果闭包如果使用不当，可以导致环形引用。所以要合理使用闭包

2. 意外的全局变量引起的内存泄露

解决：使用严格模式或者将使用过后的全局变量设置为 null 或者将它重新赋值

```js
function fn(){	
	a = "123"; //a成为一个全局变量，不会被回收
}
// 上面的写法等价于
function fn() {
	window.a = '123'
}

function fn() {
	this.a = 'test'
	// 函数自身发生调用，this指向全局对象window
}
foo();

```

3. 未清理的DOM元素引用

```js
var a = document.getElementById('id');
document.body.removeChild(a);
```

不能回收，因为存在变量a对它的引用。虽然我们用removeChild移除了，但是还在对象里保存着#的引用，即DOM元素还在内存里面。
**解决方法**： a = null;

4. 被遗忘的定时器或者回调

```js

var someResouce=getData();
setInterval( function(){
var node= document.getElementById( 'Node');
if(node){
node.innerHTML= JSON.stringify(someResouce)
}
}, 1000)
//这样的代码很常见, 如果 id 为 Node 的元素从 DOM 中移除, 该定时器仍会存在, 同时, 因为回调函数中包含对 someResource 的引用, 定时器外面的 someResource 也不会被释放。
```

5. console

控制台日志记录对总体内存内置文件的影响，也是个重大的问题，同时也是容易被忽略的。记录错误的对象，可以将大量的数据保留在内存中。传递给console.log的对象是不能被垃圾回收，所以没有去掉console.log可能会存在内存泄漏~~~~

6. 怎样避免内存泄露

1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；

2）注意程序逻辑，避免“死循环”之类的 ；

3）避免创建过多的对象 原则：不用了的东西要及时归还。



### javascript 的垃圾回收机制讲一下

定义：指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。

JavaScript 在创建对象(对象、字符串等)时会为它们分配内存，不再使用对时会“自动”释放内存，这个过程称为垃圾收集。

> JavaScript具有垃圾收集器，垃圾收集器会按照固定的时间间隔周期性的执行。

最常见的垃圾回收方式有两种： 

标记清除
引用计数
1.标记清除：
原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。

垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。
去掉环境中的变量以及被环境中的变量引用的变量的标记。
再被加上标记的会被视为准备删除的变量。
垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。
2.引用计数
原理：跟踪记录每个值被引用的次数。

声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。
同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1。
当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1。
当引用次数变成0时，说明没办法访问这个值了。
当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。
（注意：当循环引用的时候就会释放不掉内存。）

> 四种常见的内存泄漏：全局变量，未清除的定时器，闭包，以及 dom 的引用

1. 全局变量 不用 var 声明的变量，相当于挂载到 window 对象上。如：b=1; 解决：使用严格模式
2. 被遗忘的定时器和回调函数
3. 闭包
4. 没有清理的 DOM 元素引用



### 什么时候不能使用箭头函数

#### **箭头函数**

箭头函数是和我们工作密切相关的东西；可以说箭头函数的诞生，给我们的工作带来了极大的便利。但是**箭头函数有什么缺点？什么时候不能使用箭头函数？** 这你了解吗?
我们觉得箭头函数很高级，可以规避 this 的问题，所有的场景下都是用箭头函数。在不能使用的场景下使用了，出现了问题，你还不知道是什么问题，那这不是瞎添乱吗！是不是！

这里给大家先提出一个问题：

```js
const obj = {
    name: '张三',
    getName() {
        return this.name
    },
    getName1: () => {
        return this.name
    }
}
obj.__proto__.getName2 = function() {
    return this.name
}
obj.__proto__.getName3 = () => {
    return this.name
}
console.log('普通函数',obj.getName())
console.log('普通函数',obj.getName2())
console.log('箭头函数',obj.getName1())
console.log('箭头函数',obj.getName3())
复制代码
```

大家觉得会输出什么呢？

先悄悄思考一下！

3,2,1 公布答案!





![图片](https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRSribCLDqlDFAGv5feLNicg8b9fP82Ys5EzuP0frXArYgLEn9pFh69AtSWzeeh5eicvty2ZhYvAq0vQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)image.png

如果答错了，也别灰心，毕竟网络有着35的延迟，影响着你的操作和思考，看完这篇文章，保证你就不会答错了！

#### **箭头函数有什么缺点？**

1. 没有 arguments,如果要用，可以用 rest 参数代替。这里我们定义一个箭头函数和一个普通函数还有一个使用 rest 参数的箭头函数：

   ```js
   const fn1 = () => {
   console.log('arguments', arguments)
   }
   fn1(100, 200)
   
   function fn2(){
   console.log('arguments', arguments)
   }
   fn2(100, 200)
   
   const fn3 = (...values) => {
   console.log('values', values)
   }
   fn3(100, 200)
   复制代码
   ```

   ![图片](https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRSribCLDqlDFAGv5feLNicg8aibwNAIyMxkibpfCIvOGls3wZtCEU9Ruv3PiciaOoQUMPFB9ibEqu1IaGSA/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)image.png

2. 无法通过 apply、call、bind 改变this指向 这里我们在定义一个箭头函数和一个普通函数

   ```js
   const fn3 = () => {
   console.log('this', this)
   }
   fn3()
   
   function fn4(){
   console.log('this', this)
   }
   fn4()
   复制代码
   ```

   箭头函数的this就是他父容器的this，不是在执行的时候确定的，而是在定义的时候确定的。

   ![图片](https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRSribCLDqlDFAGv5feLNicg89F4gqlcp2HAbicMZ8eILseSITOIjRUOwZr1Io3iaqqibCCvHI85CmQibgg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)如上图，我们可以发现，箭头函数的两次执行的 **this 都是指向了 Windows**，**使用call并没有发生改变**，而普通函数**第一次是指向了Windows**，**第二次则是变成了我们传入的**



#### **1. 对象方法中，不适用箭头函数**

```js
const obj = {
    name: '张三',
    getName() {
        return this.name
    },
    getName1: () => {
        return this.name
    }
}
复制代码
```

我们在对象中定义了**普通函数：getName**和**箭头函数 getName1**，接下来我们来调用一下：

```js
console.log('普通函数',obj.getName())
console.log('箭头函数',obj.getName1())
复制代码
```

这里给大家默想3s输出什么？

公布答案：![图片](https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRSribCLDqlDFAGv5feLNicg8EKr7tiaRZ37dMSvEnzjE0NqYwW2J1XQnPNX5mKRngbXq0VagLib2uXRw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)我们发现箭头函数好像并没有获取到值诶！

##### 为什么对象方法中，箭头函数的this指向不是这个对象？

1. **this 永远指向函数的调用者**
2. 在箭头函数中，**this 指向的是定义时所在的对象，而不是使用时所在的对象**。换句话说，箭头函数没有自己的 this，而是继承父作用域中的 this。

`obj.getName()`中`this`指向函数的调用者，也就是`obj`实例，因此`this.name = "张三"`。

`getName1()`通过箭头函数定义，而箭头函数是没有自己的`this`，会继承父作用域的`this`。

因此`obj.getName1()`执行时，此时的作用域指向`window`，而`window`没有定义`age`属性，所有报空。

从例子可以得出：**对象中定义的函数使用箭头函数是不合适的**。

#### **2. 原型方法中，不适用箭头函数**

```js
const obj = {
    name: '张三',
}
obj.__proto__.getName = function() {
    return this.name
}
obj.__proto__.getName1 = () => {
    return this.name
}
复制代码
```

我们又又又在对象中定义了**普通函数：getName**和**箭头函数 getName1**，接下来我们来调用一下：

```js
console.log(obj.getName())
console.log(obj.getName1())
复制代码
```

这里再再再给大家默想3s输出什么？

bang bang bang 公布答案：![图片](https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRSribCLDqlDFAGv5feLNicg8ZQR1c9qv37ZQibGEXCU3dKeNYs76jGG22urm4ecAqkO0bEZ3DWAs6lw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)

##### 为什么？

出现问题的原因是this指向window对象，这和使用箭头函数在对象中定义方法十分类似。

#### **3. 构造函数也不行！**

我们又又又定义了**普通的构造函数：Foo**和**箭头函数 Foo1**，接下来我们来调用一下：

```js
function Foo (name, sex) {
    this.name = name
    this.sex = sex
}
const Foo1 = (name, sex) => {
    this.name = name
    this.sex = sex
}
console.log('普通的构造函数：', new Foo('张三', '男'))
console.log('箭头函数：', new Foo1('张三', '男'))
复制代码
```

不仅不行，还报错了呢！![图片](https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRSribCLDqlDFAGv5feLNicg8W694JYPP5hc1L6eibrL88HXnjjpwDPUDpXoQhmIugA4rHah42XPz0eQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)

##### 为什么？

> 构造函数是通过 new 关键字来生成对象实例，生成对象实例的过程也是通过构造函数给实例绑定 this 的过程，而箭头函数没有自己的 this。因此不能使用箭头作为构造函数，也就不能通过 new 操作符来调用箭头函数。

#### **4. 动态上下文中的回调函数**

比如，我们需要给一个按钮添加点击事件：

```js
const btn1 = document.getElementById('btn1')
btn1.addEventListener('click', () => {
    this.innerHTML = 'clicked'
})
复制代码
```

如果我们在回调中不需要使用到 this，那就啥问题也没有，但是！使用到了 this，那么问题就大大的了！

##### **为什么呢？**

**箭头函数的 this 指向的是他的父作用域**（这里就指向了 window），而不是指向这个button。这时候我们需要使用普通函数才可以。

#### **5. Vue 生命周期和 method 中也不能使用箭头函数**

![图片](https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRSribCLDqlDFAGv5feLNicg8FtnRw8udNiakgqbSVC0ZAQlic91PHNOyuYS5dbjvicrVdJ5DfjhktPBLQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)image.png

##### 为什么不行呢？

Vue 本质上是一个对象，我们说过对象方法中，不适用箭头函数。他的本质上的和对象方法中，不适用箭头函数是一样的。

那么我有一个问题：Vue不行，作为大热框架之一的 react 行吗？

回答是：react 行

因为 Vue组件本质上是一个 JS 对象；React 组件（非Hooks）他本质上是一个 ES6 的 class

不信的话我们测试一下就知道了

```js
class Man {
    constructor(name, city) {
        this.name = name
        this.city = city
    }
    getName = () => {
        return this.name
    }
}
const f = new Man('李四','上海')
console.log(f.getName())
复制代码
```

![图片](https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRSribCLDqlDFAGv5feLNicg8yK8Ha29TibaXIxs5GJGRYUnfULv6SZuUZB2icdNCf1IeDCEY43m2Wibbw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)image.png

#### **划重点**

- 要熟练使用箭头函数，也要对函数 **this**（重点） 敏感
- Vue组件本质上是一个 JS 对象；React 组件（非Hooks）他本质上是一个 ES6 的 class，两者不同

The end



### null 和 undefined 究竟有何区别？

[深入探究：null 和 undefined 究竟有何区别？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/463090509)



### 内存泄漏是什么，以及原因

内存泄漏：由于疏忽未能释放已经不在使用的内存，如果内存泄漏的位置比较关键，那么随着处理的进行会产生更多的无用内存，这些无用的内存会 使服务器响应变慢

原因：



### 谈谈对ES6的理解

新增了不少新的功能比如说：

- 模板字符串
- 箭头函数（Rest参数）
- 类
- Promise构造函数，async和await
- let、const、块级作用域
- module模块化的概念
- 可选链
- Set集合和Map集合



### var和let const的区别

- var ES5的语法，let和const ES6的语法

- var有变量提升，let和const没有
- let和const有块级作用域
- let和const不可以重复声明
- var和let是变量可以修改，const是常量一旦声明就要赋值而且还不能修改



### 列举强制类型转换和隐式类型转换

强制：

- parseInt()
- parseFloat() 
- toString()
- Number()

隐式：

- 加减乘除
- 逻辑运算
- ==
- +拼接字符串

[JS强制类型转换和隐式类型转换 (biancheng.net)](http://c.biancheng.net/view/8101.html#:~:text=在 JavaScript 中，数据类型的转换有：隐式类型转换和强制类型转换（也叫显式类型转换）两种方式。 1. 隐式类型转换 隐式类型转换会自动根据运算符进行类型转换。,隐式类型转换的情况主要有以下几种。 1) 如果表达式中同时存在字符串类型和数字类型的操作数，而运算符使用加号 %2B ，此时 JavaScript 会自动将数字转换成字符串。)



### 手写模拟ladash isEqual



### 0.1+0.2

JavaScript 里的数字是采用 [IEEE 754 标准](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/IEEE_754)的 64 位双精度浮点数。

然后0.1 和 0.2相加的时候，将十进制的0.1和0.2转化成二进制，由于浮点数的用二进制表达时是无穷的，

[JavaScript 浮点数运算的精度问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/191395766)

[JavaScript 中精度问题以及解决方案 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/js-precision-problem-and-solution.html)

## ES6

### ES6新增了哪些

### ES6新增的数组方法

#### 拓展运算符 ...

```js
// ES5 的写法
Math.max.apply(null, [14, 3, 77])
// ES6 的写法
Math.max(...[14, 3, 77])
// 等同于
Math.max(14, 3, 77);
```

#### Array.from()

`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）

```js
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']
// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

#### Array.of()

`Array.of`方法用于将一组值，转换为数组。

```js
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
```

与空数组的区别：

`Array.of()` 和 `Array` 构造函数之间的区别在于处理整数参数：`Array.of(7)` 创建一个具有单个元素 **7** 的数组，而 `Array(7)`创建一个长度为 7 的空数组（**注意：**这是指一个有 7 个空位 (empty) 的数组，而不是由 7 个`undefined`组成的数组）

```js
Array.of(7);       // [7]
Array.of(1, 2, 3); // [1, 2, 3]

Array(7);          // [ , , , , , , ]
Array(1, 2, 3);    // [1, 2, 3]
```

#### find() 和 findIndex()

数组实例的`find`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined 。

```js
[1, 4, -5, 10].find((n) => n < 0)
// -5
```

数组实例的 `findIndex` 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置

```js
[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value > 9;
}) // 2
```

#### fill()

`fill()` 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。

```js
const array1 = [1, 2, 3, 4];

// fill with 0 from position 2 until position 4
console.log(array1.fill(0, 2, 4));
// expected output: [1, 2, 0, 0]

// fill with 5 from position 1
console.log(array1.fill(5, 1));
// expected output: [1, 5, 5, 5]

console.log(array1.fill(6));
// expected output: [6, 6, 6, 6]
```

#### includes()

`includes()` 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 `true`，否则返回 `false`

```js
const array1 = [1, 2, 3];

console.log(array1.includes(2));
// expected output: true
```


#### entries()，keys() 和 values()

ES6 提供三个新的方法—— `entries()` ，`keys()` 和 `values()`——用于遍历数组。它们都返回一个`遍历器对象`（详见《Iterator》一章），可以用 for...of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、 values() 是对键值的遍历， entries() 是对键值对的遍历。

```js
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1
for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'
for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

#### flat()，flatMap()

`flat()` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回（多维变一维）。

```js
var arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

var arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

//使用 Infinity，可展开任意深度的嵌套数组
var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

`flatMap()`方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map() ），然后对返回值组成的数组执行 flat() 方法。该方法返回一个新数组，不改变原数组。

```js
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]
```

#### Array.prototype.at()

`at()`方法接收一个整数值并返回该索引的项目，允许正数和负数。负整数从数组中的最后一个项目开始倒数。

```js
const cart = ['apple', 'banana', 'pear'];

console.log(cart.at(0)) // 'apple'

// 一个函数，用于返回给定数组的最后一个项目
function returnLast(arr) {
  return arr.at(-1);
}

console.log(returnLast(cart));
```



### ES6新增的对象方法

#### Object.is()

比较两个值是否相等，相等返回true，接收两个参数。

```js
Object.is(NaN, NaN) // true
Object.is({},{}) // false
Object.is(+0,-0) // false
// 与三等于比较
+0 === -0 //true
NaN === NaN // false
```

实现原理：

```js
Object.defineProperty(Object, 'is', {
  value: function(x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x && y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});
```

#### Object.assign()

`Object.assign`方法用于对象的合并，将`源对象`（source）的所有`可枚举`属性，复制到目标对象（target）

```js
let obj1 = { a: 1 }
// 一般使用一个空对象，不影响其源对象
Object.assign({},obj1) // { a: 1 }
```

注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。如果只有一个参数，`Object.assign` 会直接返回该参数。`Object.assign`方法实行的是`浅拷贝`，而不是深拷贝。

```js
let obj = { a: 1 }
Object.assign(obj) === obj // true
```

####  Object.getOwnPropertyDescriptors()

ES5 的 `Object.getOwnPropertyDescriptor()`方法会返回某个对象属性的`描述对象`（descriptor）。ES2017 引入了`Object.getOwnPropertyDescriptors()`方法，返回指定对象所有`自身属性`（非继承属性）的描述对象。Object.getOwnPropertyDescriptors()`方法返回一个`对象

```js
Object.getOwnPropertyDescriptors({a:1})
// 返回的结果
{
	a: {
    configurable: true
    enumerable: true
    value: 1
    writable: true
  }
}
```

实现原理：

```js
// 补充
Reflect.ownKeys({a:1})
// ['a']
Object.keys({a:1})
// ['a']
function getOwnPropertyDescriptors(obj) {
  const result = {};
  for (let key of Reflect.ownKeys(obj)) {
    result[key] = Object.getOwnPropertyDescriptor(obj, key);
  }
  return result;
}
```

#### Object.getPrototypeOf()和Object.setPrototypeOf()

`Object.getPrototypeOf()` 方法返回指定对象的原型（内部`[[Prototype]]`属性的值）。

```js
Object.getPrototypeOf(obj);
Object.getPrototypeOf(1) === Number.prototype // true
```

`Object.setPrototypeOf()` 方法设置一个指定的对象的原型 ( 即，内部 [[Prototype]] 属性）到另一个对象或  [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null)。

```js

Object.setPrototypeOf(obj, proto);
// 等同于
function setPrototypeOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
```

#### Object.keys()，Object.values()，Object.entries()

`Object.keys()` 方法会返回一个由一个给定对象的自身可枚举属性组成的数组

```js
var obj = { foo: 'bar', baz: 42 };
Object.keys(obj)
// ["foo", "baz"]

var arr = ['a', 'b', 'c'];
console.log(Object.keys(arr)); // console: ['0', '1', '2']
```

`Object.values()`方法返回一个给定对象自身的所有可枚举属性值的数组

```js
var obj = { foo: 'bar', baz: 42 };
console.log(Object.values(obj)); // ['bar', 42]
```

`Object.entries()`方法返回一个给定对象自身可枚举属性的键值对数组

```js
const obj = { foo: 'bar', baz: 42 };
console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]
```

[ES6 对象的新增方法_w3cschool](https://www.w3cschool.cn/escript6/escript6-1vdc37f2.html)

## TS

### const 和 readonly 的区别

（1）const 用于变量， readonly 用于属性

（2）const 在运行时检查， readonly 在编译时检查

（3）const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值；

　　readonly 修饰的属性能确保自身不能修改属性，但是当你把这个属性交给其它并没有这种保证的使用者（允许出于类型兼容性的原因），他们能改变

```js
const foo: {
  readonly bar: number;
} = {
  bar: 123
};
function iMutateFoo(foo: { bar: number }) {
  foo.bar = 456;
}
iMutateFoo(foo);
console.log(foo.bar); // 456
```


（4）const 保证的不是变量的值不得改动，而是变量指向的那个内存地址不得改动，例如使用 const 变量保存的数组，可以使用 push ， pop 等方法。

### 枚举和常量枚举的区别

  (1) 枚举会被编译时会编译成一个对象，可以被当作对象使用

（2）const 枚举会在 typescript 编译期间被删除，const 枚举成员在使用的地方会被内联进来，避免额外的性能开销

　　我们先看下面代码，枚举会被编译成什么：


```js
// 枚举
enum Color {
  Red,
  Green,
  Blue
}
var sisterAn = Color.Red
// 会被编译成 JavaScript 中的 var sisterAn = Color.Red
// 即在运行执行时，它将会查找变量 Color 和 Color.Red

```

我们再看下 常量枚举 会被编译成什么：

```js
// 常量枚举
const enum Color {
  Red,
  Green,
  Blue
}
var sisterAn = Color.Red
// 会被编译成 JavaScript 中的 var sisterAn = 0
// 在运行时已经没有 Color 变量
```

由此可见，使用 常量枚举 会有更好的性能。



浅析TypeScript中const和readonly的区别、枚举和常量枚举的区别以及关于typescript中枚举的相关知识
https://blog.51cto.com/u_15049782/4295366



### 函数重载

函数重载就是说同一个函数可以接收不同数量的参数以及类型，比如说传入一个number类型就只能返回number类型， 传入string类型就只能传入string类型

[TypeScript 函数的重载 - 掘金 (juejin.cn)](https://juejin.cn/post/7029481950691737630)



### 类型保护的方式有哪些

- in 语法
  - 当类型区别于其他方法有特定的属性是可以用in语法来保护类型启用对应的类型方法和属性等

```js
interface Brid {
    fly: boolean
    sing: () => {}
}

interface Dog {
    fly: boolean
    bark: () => {}
}

function tranAnialSecond(animal: Brid | Dog) {
    // in 语法实现类型保护
    if ('sing' in animal) {
        animal.sing()
    } else {
        animal.bark()
    }

}
```

- typeof
  - 当某数据类型是指定的某原始类型,可以用typeof结合===运算符进行类型保护

```js
function add(first: string | number, second: string | number) {
    // typeof 语法实现类型保护
    if (typeof first === 'string' || typeof second === 'string') {
        return `${first}${second}`
    }
    return first + second
}
```

 





## Linux

### Vim编辑器



![image-20220720141934533](images/image-20220720141934533.png)



### 用户组

添加用户：useradd 用户名

修改密码：passwd 用户名

切换用户：su 用户名



### 文件目录

![image-20220720142405873](images/image-20220720142405873.png)

### 权限（重点）

>权限的基本介绍

ls -l 指令中显示的内容如下：
-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc
0-9 位说明
第 0 位确定文件类型(d, - , l , c , b)

- l 是链接，相当于 windows 的快捷方式 

- d 是目录，相当于 windows 的文件夹

- c 是字符设备文件，鼠标，键盘

- b 是块设备，比如硬盘

第 1-3 位确定所有者（该文件的所有者）拥有该文件的权限。---User

第 4-6 位确定所属组（同用户组的）拥有该文件的权限，---Group

第 7-9 位确定其他用户拥有该文件的权限 ---Other

> rwx 权限详解，难点

- [ r ]代表可读(read): 可以读取,查看
- [ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.
- [ x ]代表可执行(execute):可以被执行

第一组 rwx : 文件拥有者的权限是读、写和执行

第二组 rw- : 与文件拥有者同一组的用户的权限是读、写但不能执行

第三组 r-- : 不与文件拥有者同组的其他用户的权限是读不能写和执行

可用数字表示为: r=4,w=2,x=1 因此 rwx=4+2+1=7 , 数字可以进行组合

> 修改权限

chmod u=rwx,g=rx,o=x 文件目录名

相当于 chmod 751 文件/目录名



### 磁盘管理

> 磁盘使用情况

df -h



### 网络配置

> 查看网络配置

```bash
跟window差了个p
ifconfig
```

> 测试主机连通性

ping 目的主机 ,默认80端口

协议：ICMP是“Internet Control Message Ptotocol”的缩写。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。

> window清除dns缓存

查看：ipconfig/displaydns

清除：ipconfig/flusdns

### 进程管理

> 查看进程

ps 

pstree     ---表示树状展示

-a 显示当前终端的所有进程信息

-u 以用户的格式显示进程信息

-x 显示后台运行的参数

-e 显示所有进程

-f 全格式 可以看到父进程

可以配合管道符和grep过滤如：ps -aux | grep nginx

> 终止进程

kill 进程号(PID)

killall

-9  表示强制

> 服务管理

service 服务名 [start | stop | restart | reload | status]

现在都常用systemctl

查看运行级别：runlevel

systemctl [start | stop | restart | status] 服务名

> 查看自启动状态

systemctl list-unit-files [ | grep 服务名] (查看服务开机启动状态, grep 可以进行过滤)

systemctl enable 服务名 (设置服务开机启动)

systemctl disable 服务名 (关闭服务开机启动)

systemctl is-enabled 服务名 (查询某个服务是否是自启动的)

> 防火墙相关的

打开端口: firewall-cmd --permanent --add-port=端口号/协议

关闭端口: firewall-cmd --permanent --remove-port=端口号/协议

重新载入,才能生效 : firewall-cmd --reload

查询端口是否开放: firewall-cmd --query-port=端口/协议

> 监控网络情况

netstat

-an 按一定输出显示

-p 哪个进程在调用

### 包管理

> rpm

rpm 用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有.RPM 扩展名的文件。

查看所以已安装的：rpm -qa

卸载：rpm -e 包名

安装：npm - ivh 包名

> yum

Yum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。

查询 yum 服务器是否有需要安装的软件：yum list | grep 软件名

下载安装：yum install xxx

### Shell 脚本

- 脚本以#!/bin/bash 开头
- 脚本需要有可执行权限

>  编写第一个 Shell 脚本

需求说明：创建一个 Shell 脚本，输出 hello world!

```sh
vim hello.sh

#!/bin/bash
echo "hello,world~"
```

./hello.sh 即可执行



## 网络

### 说下HTTP状态码？

分类：

> 1xx 服务器收到请求
>
> 2xx 请求成功，如200
>
> 3xx 重定向，如302
>
> 4xx 客户端错误，如404
>
> 5xx 服务端错误，如500

常见状态码：

> 200：请求成功
>
> 301：永久重定向（配合location，浏览器自动处理）
>
> 302：临时重定向（配合location，浏览器自动处理）配合例子介绍
>
> 304：资源未被修改（重要） 本地缓存还有效
>
> 
>
> 404：资源未找到
>
> 403：没有权限
>
> 500：服务器错误
>
> 504：网关超时



### http常见的headers有哪些？

Request Headers

> Accept：定义客户端（浏览器）可接受的响应内容类型（数据格式）；
>
> Accept-charset：定义客户端可接受的字符集；
>
> Accept-Encoding：定义客户端可接受的编码方式（压缩算法），比如打包方式--gzip 等；
>
> Accept-Languange：浏览器可接收的语言，如zh-CN；
>
> Connection：keep-alive 一次TCP连接重复使用；
>
> cookie：由服务器通过 set-cookie 设置的 cookie；
>
> Content-Length：请求体的长度；
>
> Content-Type：请求体的数据类型：Content-Type: application/x-www-form-urlencoded；
>
> Date：发送该请求的日期和时间；
>
> Host：所请求的服务器地址；
>
> Referrer：表示页面是从哪个地链接过来的，可以用来统计网页上的链接访问量；
>
> User-Agent：显示客户端的身份标识；
>
> If-Modified-Since：用于协商缓存，取自 Response haders 中的 Last-Modified 字段。服务器通过对比这两个字段判断缓存是否有效；
>
> If-None-Match：用于协商缓存，取自 Response Headers 中的 E-tag 字段。服务器通过对比这两个字段判断缓存是否有效；

Response Headers

> Access-Control-Allow-Origin：指定哪些网站以跨域资源共享（CORS）；
>
> Content-Encoding：响应资源的编码方式；
>
> Content-Language：响应资源所使用的语言；
>
> Content-Length：响应资源的长度；
>
> Content-type：响应内容的数据类型（格式）；
>
> Date：消息被发送时的日期和时间；
>
> Location：用于重定向；
>
> Set-Cookie：用于设置客户端的 cookie ；
>
> Status：用来说明当前 Http 连接的状态；
>
> Last-Modified：服务器返回给客户端，下次请求通过在 Resquest Headers 中的 If-Modified-Since 字段携带过来。
>
> E-tag：服务器返回给客户端，下次请求通过在 Resquest Headers 中的 If-None-Matched 字段携带过来。
>
> Cache-Control：
>
> max-age：缓存有效期，浏览器自己通过计时判断缓存是否过期。如果未过期则命中强制缓存。
>
> no-cache：不使用强制缓存，直接进入协商缓存。
>
> no-store：不使用缓存，每次请求都会进行 http 请求。
>
> 

缓存的相关的

> 协商缓存的
>
> response
>
> Last-Modified：资源最后的修改时间，服务器返回给客户端，下次请求通过在 Resquest Headers 中的 If-Modified-Since 字段携带过来。
>
> E-tag：资源的唯一标识，服务器返回给客户端，下次请求通过在 Resquest Headers 中的 If-None-Matched 字段携带过来。
>
> request
>
> If-Modified-Since：用于协商缓存，取自 Response haders 中的 Last-Modified 字段。服务器通过对比这两个字段判断缓存是否有效；
>
> If-None-Match：用于协商缓存，取自 Response Headers 中的 E-tag 字段。服务器通过对比这两个字段判断缓存是否有效；

强制缓存的

> Cache-Control：可以控制强制缓存的逻辑 有一下可能
>
> - max-age：23423        单位是秒，缓存有效期，浏览器自己通过计时判断缓存是否过期。如果未过期则命中强制缓存。
> - no-cache：不使用强制缓存，直接进入协商缓存。
> - no-store：不使用缓存，每次请求都会进行 http 请求。
> - private
> - public
>
> Expires：同为控制缓存过期（渐渐被上面Cache-Control代替）老，担兼容两个写法

自定义的请求头



### 什么是Restful API

传统的methods

- get 获取服务器的数据
- post 向服务器提交数据

现在的methods

- get 获取数据
- post 新建数据，比如说数据还没有 新的去创建
- patch/put 更新数据
- delete 删除数据

Restful API

> 传统API设计：把每个url当做一个功能
>
> Restful API设计：把每个url当做一个唯一资源（主要看methods和唯一表示）



### 描述下http缓存机制（重要）

[http面试必会的：强制缓存和协商缓存 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903838768431118)



### get和post区别

1. GET提交的数据放在URL中，POST则不会。这是最显而易见的差别。这点意味着GET更不安全（POST也不安全，因为HTTP是明文传输抓包就能获取数据内容，要想安全还得加密）
2. GET回退浏览器无害，POST会再次提交请求（GET方法回退后浏览器再缓存中拿结果，POST每次都会创建新资源）
3. GET提交的数据大小有限制（是因为浏览器对URL的长度有限制，GET本身没有限制），POST没有
4. GET可以被保存为书签，POST不可以。这一点也能感受到。
5. GET能被缓存，POST不能
6. GET只允许ASCII字符，POST没有限制
7. GET会保存再浏览器历史记录中，POST不会。这点也能感受到。

总之，两者之间没有本质区别，区别就在于数据存储的位置。各自有适用环境，根据需求选择合适的方法即可。

<img src="https://cdn.jsdelivr.net/gh/Pu-feng/mdimages/202207071601477.png"/>



### 请求方法

客户端发起 HTTP 请求，服务器响应客户端请求，客户端可以对服务器端的资源进行操作，例如查询、添加、删除等，但具体执行哪种操作喃？

这就是请求方法存在的意义，它规定了客户端的某种操作指令，用来告诉服务器端我需要进行哪种操作，常见的请求方法有：

- GET ：获取资源，常用于读取或下载资源
- HEAD ：请求一个与 GET 请求的响应相同的响应，只返回请求头，没有响应体，多数由 JavaScript 发起
- POST ：用于将实体（body）提交到指定的资源，通常导致状态或服务器上的副作用的更改
- PUT ：用请求有效载荷替换目标资源的所有当前表示。
- DELETE ：删除指定的资源。
- CONNECT ：建立一个到由目标资源标识的服务器的隧道，多用于 HTTPS 和 WebSocket 。
- OPTIONS ：预检，用于描述目标资源的通信选项。通过该请求来知道服务端是否允许跨域请求。
- TRACE ：沿着到目标资源的路径执行一个消息环回测试，多数线上服务都不支持
- PATCH ：用于对资源应用部分修改。

GET 请求方法应该是 HTTP 所有请求方法中最开始出现的了，它表示从服务器获取资源

POST 请求方法是 HTTP 所有协议中除 GET 之外最常使用的请求方法了，它表示向指定的服务器资源提交数据，提交数据存放在 HTTP 报文中的 body 中，通常导致状态或服务器上的副作用的更改



### POST 方法比 GET 方法安全？

在 HTTP 协议里，所谓的“安全”是指请求方法不会对服务器上的资源进行修改，“破坏”服务器上的资源

按照这种定义，GET 请求方法是安全的，它对服务器资源执行的仅仅是只读操作，也是幂等的

> 幂等指多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”

POST 请求方法是不安全的，它会修改服务器上的资源，在 RFC 里的语义，POST 是指“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的

总结：

- GET：安全，幂等
- POST：不安全，不幂等

> 对于传输来说，GET 和 POST 报文在传输上都是不安全的，因为 HTTP 在网络上是明文传输的，想要安全传输就得加密，也就是 HTTPS

[(4条消息) 你真的了解 GET 和 POST 吗，它们的区别是什么？_前端瓶子君的博客-CSDN博客](https://blog.csdn.net/lunahaijiao/article/details/119833898#:~:text=对于传输来说，GET 和 POST 报文在传输上都是不安全的，因为 HTTP 在网络上是明文传输的，想要安全传输就得加密，也就是,HTTPS 2. POST 方法会产生两个 TCP 数据包？)



## 浏览器方面

### 浏览器原理

首先浏览器的话是一个多进程的程序，他的进程有：浏览器主进程（主要负责页面的交互和显示（一个）），渲染进程（浏览器的内核，核心就是将html和css和js转化为我们的页面（多个）），GPU进程（用来绘制页面（一个）），网路进程（负责网路资源的加载（一个）），插件进程（负责页面的插件（多个））





### 浏览器架构

进程：启动一个程序的时候，操作系统会为程序创建一个内存空间，用来存放代码，运行中的数据、文件、执行任务的主线程

线程：依附于进程，可以使用多个线程处理任务

<img src="https://cdn.jsdelivr.net/gh/Pu-feng/mdimages/202207062251118.png"/>

<img src="https://cdn.jsdelivr.net/gh/Pu-feng/mdimages/202207062252292.png"/>

<img src="https://cdn.jsdelivr.net/gh/Pu-feng/mdimages/202207082208087.png"/>



### url到渲染出页面的整个过程

1. DNS解析：域名->IP地址

----中间一大堆-----

<img src="https://cdn.jsdelivr.net/gh/Pu-feng/mdimages/202207082213568.png"/>

2. 浏览器根据IP像服务器发http请求

----也是一大堆处理----

3. 服务处理http请求，并返回给浏览器

----又是一大堆处理----

4. 页面渲染过程

根据HTML代码通过HTML解析器生成DOM树

根据CSS代码通过CSS解析器生成CSSOM

将DOM树和CSSOM结合成Render tree

~~然后布局，就是将节点放到浏览器界面的对应位置~~

~~最后进行绘制，把页面渲染到页面~~

根据Render tree生成页面

遇到script标签，暂停渲染，先加载并执行js代码，完成再继续（js线程和渲染线程运行在同一个进程里面，也是拓展里面）

再继续渲染直到完成



参考：

[javascript单线程与浏览器的渲染 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/475645248)

[多进程浏览器、多线程页面渲染与js的单线程 - 地铁程序员 - 博客园 (cnblogs.com)](https://www.cnblogs.com/yiyi17/p/8645830.html)

拓展：

**GUI渲染线程**

- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
- 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。

**JS引擎线程**

- 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
- JS引擎线程负责解析Javascript脚本，运行代码。
- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
- 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。



### 浏览器内核（渲染进程）

```
GUI渲染线程
```

- 负责渲染页面，布局和绘制
- 页面需要重绘和回流时，该线程就会执行
- 与js引擎线程互斥，防止渲染结果不可预期

```
JS引擎线程
```

- 负责处理解析和执行javascript脚本程序
- 只有一个JS引擎线程（单线程）
- 与GUI渲染线程互斥，防止渲染结果不可预期

```
事件触发线程
```

- 用来控制事件循环（鼠标点击、setTimeout、ajax等）
- 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中

```
定时触发器线程
```

- setInterval与setTimeout所在的线程
- 定时任务并不是由JS引擎计时的，是由定时触发线程来计时的
- 计时完毕后，通知事件触发线程

```
异步http请求线程
```

- 浏览器有一个单独的线程用于处理AJAX请求
- 当请求完成时，若有回调函数，通知事件触发线程



### 为什么JS是单线程

1、什么是线程？

线程是CPU调度的最小单位，同时也是进程的最小组成单位。

2、什么是单线程？

进程是可以包含多个线程的，但是如果一个进程上只有一个线程，那么就叫单线程。也就意味着所有任务需要排队，前一个任务结束，才会执行后一个任务。

3、为什么JS是单线程？

交互方式决定单线程模式。JS被设计用来实现用户与浏览器的交互，包括dom的增删改，如果使用多线程模式，会带来很多复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

总结：为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征。为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。
————————————————
版权声明：本文为CSDN博主「花海里没有花」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_41273347/article/details/118945097



### 同步、异步、事件循环

JavaScript是一门**单线程**的语言，因此，JavaScript在同一个时间只能做一件事，单线程意味着，如果在同个时间有多个任务的话，这些任务就需要进行排队，前一个任务执行完，才会执行下一个任务。

js运行机制：先执行同步代码 后异步代码

**同步任务**

同步任务是指在**主线程**上排队执行的任务，形成一个**执行栈**。只有前一个任务执行完毕，才能继续执行下一个任务。

当我们打开网站时，网站的渲染过程，比如元素的渲染，其实就是一个同步任务

**异步任务**

异步任务是指不进入主线程，而进入任务队列（消息队列）的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。

当我们打开网站时，像图片的加载，音乐的加载，其实就是一个异步任务。是通过回调函数实现的。有以下三种：

1. 普通事件：click、resize
2. 资源加载：load、error
3. 定时器：setInterval、setTimeout
4. then() 方法和 catch() 方法

```js
// 定时器里面的内容异步 还有事件里面的异步
// 例一
    console.log(1);
    setTimeout(function () {
        console.log(2);
    }, 0)
    console.log(3);
    setTimeout(function () {
        console.log(4);
    }, 0)
    // 输出 1 3 2 4

// 例二
    for (var i = 0; i < 3; i++) {
        console.log(i);
        // 异步 最后执行
        setTimeout(function () {
            console.log(i);
        }, 0)
    }
    // 输出 0 1 2 3 3 3
```

> 异步任务执行机制

1.所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
2.主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
3.一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4.主线程不断重复上面的第三步。

#### Event Loop 

[(1条消息) 面试题：说说事件循环机制(满分答案来了)_winty~~的博客-CSDN博客](https://blog.csdn.net/LuckyWinty/article/details/104765786?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-104765786-blog-119788483.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-104765786-blog-119788483.pc_relevant_default&utm_relevant_index=2)

[(1条消息) 带你了解事件循环机制(Event Loop)_**Crazy的博客-CSDN博客_事件循环机制](https://blog.csdn.net/weixin_52092151/article/details/119788483)

[前端基础进阶（十四）：深入核心，详解事件循环机制 - 简书 (jianshu.com)](https://www.jianshu.com/p/12b9f73c5a4f)

> Event Loop 

是指浏览器或`Node`的一种解决`javaScript`单线程运行时不会阻塞的一种机制，也就是我们经常使用**异步**的原理。

主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

> 为什么会有Event Loop

JavaScript的任务分为两种`同步`和`异步`，它们的处理方式也各自不同，**同步任务**是直接放在主线程上排队依次执行，**异步任务**会放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到**调用栈**然后主线程执行调用栈的任务。

常见的 macro-task：`setTimeout`、`setInterval`、`script（整体代码）`、`I/O 操作`、`UI 渲染`等。

常见的 micro-task: `new Promise().then(回调)`、`MutationObserve`等。

> 浏览器循环机制

11

<img src="https://cdn.jsdelivr.net/gh/Pu-feng/mdimages/202207111506399.png"/>

> node.js事件循环机制

node.js 也是跟浏览器一样，分为宏任务和微任务，不过也有node.js独有的：process.nextTick和setImmediate，process.nextTick是独立于事件循环的任务队列。是在同步代码之后，微任务之前执行。在node.js，事件循环的主要过程有三个：

timer队列：执行好的定时器（setTimeout,setInterval）会在这里等待执行

poll队列：主要的阶段，进行I/O的操作（文件的读写、数据库的操作、网络请求），轮训，当执行到这里的时候会判断timer队列和check队列是否为空，如果为空的话，就会在这暂停，等待I/O任务的到来。

check队列：执行setImmediate的地方。

在调用栈中，同步任务执行完成，然后检查timer队列中有没有执行好的定时器，有就推入到执行栈中执行，没有就下一步；查看poll队列，要任务就推入调用栈执行，没有就检查timer队列和check队列是否为空，空就在poll队列这里暂停，等待新的I/O事件，据说这样做是为了有网络请求可以及时的处理。当然如果其中一个有任务可以执行就推入调用栈中执行，大概就是这样一个过程。

<img src="https://cdn.jsdelivr.net/gh/Pu-feng/mdimages/202207182227642.png"/>

#### 同步异步相关的题目

```js
async function async1() {
  console.log('async start'); // 2
  await async2();
  // 相当于一个宏任务 看上面是什么结果
  console.log('async1 end'); // 9
}

async function async2() {
  console.log('async2'); // 3
  return new Promise(resolve => {
    console.log('async2 promise'); // 4
    setTimeout(() => {
      // 宏任务
      console.log('setTimeout'); // 11
      // resolve('1');
    }, 1000);
    resolve();
  }).then(() => {
    // 微任务
    console.log('async 成功promise'); // 7
  });
}

console.log('script start'); // 1

setTimeout(() => {
  // 宏任务
  console.log('全局setTimeout'); // 10
}, 0);

async1();

new Promise(resolve => {
  console.log('全局promise'); // 5
  resolve();
}).then(() => {
  // 微任务
  console.log('全局成功promise'); // 8
});

console.log('script end'); // 6

// 同步代码执行完毕  call-stack 被清空
// 执行微任务
// 尝试dom渲染
// 触发 Event Loop 执行宏任务

// 需要注意的是 await后面的的任务相当于开启了微任务或者是宏任务 看await后面的promise 有没有宏任务 有就是当做宏任务

```



### window.onload 和 DOMContentLoaded 的区别

- 在文档加载完成后会触发 `load` 事件。此时，在文档中的所有对象都在 DOM 中，所有图片、脚本、样式表、链接以及子框都加载完成了。

- 当纯 HTML 被完全加载以及解析时，**`DOMContentLoaded`** 事件会被触发，而不必等待样式表，图片或者子框架完成加载。



###  JavaScript window.onload 事件和 jQuery ready 函数有何不同？

- window.onload事件是等DOM和图片和外部资源等才会去执行的，而ready的话是等DOM加载完就会执行，而不会去等待图片的加载完成。
- window.onload事件是只能写一个，因为后面写的会覆盖前面的，而ready的话是可以写多个的，是按照顺序执行

补充：DOMContentLoaded同JQuery.ready() 的触发相同，都是等DOM加载完成后触发，而JQready.ready 内部就是通过DOMContentLoader实现的，只不过他还做了些其他的处理。

DOM文档加载的步骤为：

        解析HTML结构。
        加载外部脚本和样式表文件。
        解析并执行脚本代码。
        DOM树构建完成。//DOMContentLoaded
        加载图片等外部文件。
        页面加载完毕。//load




### 性能优化方面

优化原则：多使用内存、缓存或其他方法；减少CPU计算量，减少网络加载耗时（空间换时间）

让加载更快

- 减少资源体积：压缩代码（本地webpack 中的 optimization.minimizer 服务器端：gzip）
- 减少访问次数：合并代码（Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求），SSR服务器端渲染，缓存
- 使用更快的网络：CDN内容分发网络（根据区域，就近）
- SSR：将网页和数据一起加载，一起渲染，非SSR先加载网页，再加载数据，再渲染数据

让渲染更快（感觉有点）

- CSS放在head，JS放在body最下面
- 尽早开始执行JS，用DOMContentLoaded触发
- 懒加载（图片懒加载，上滑加载更多）
- 对DOM查询进行缓存
- 频繁DOM操作，合并到一起插入DOM结构
- 节流（throttle）和防抖（debounce）
- 利用http缓存机制：文件内容不变hash不变，url不变，这样触发http缓存机制，304使用缓存

防抖：频繁多次触发事件，只执行最后一次（输入框）

```js
function debounce(fn, delay = 500) {
    let timer = null
    return function() {
        if(timer) {
            clearTimeout(timer)
        } 
        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}

// 处理事件的函数
function fn() {
    console.log('我要处理一堆事情')
}
```

节流：一段事件内执行一次，也就是限制执行次数（滚动和拖拽事件）

```js
function throttle(fn, delay = 200) {
    let timer = null
    return function() {
        if(timer) {
            return
        }
        timer = setTimeout(() => {
            // fn() 为了this指向和事件对象存在
            fn.apply(this, arguments)
            timer = null
        }, delay)
    } 
}

// 处理事件的函数
function fn() {
    console.log('我要处理一堆事情')
}
```



### require和import的区别

- 当两者混用时，优先引入import引入的文件。因为import是在编译模块时运行的，而require是在运行时运行的

- require是**CommonJS** 规范，import是**ES6** 规范

- **import/export 在浏览器中无法直接使用**，我们需要在引入模块的 <script> 元素上添加type="module" 属性

- require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用

- CommonJS 模块的`require()`是同步加载模块，ES6 模块的`import`命令是异步加载，有一个独立的模块依赖的解析阶段。

[Module 的加载实现 - ECMAScript 6入门 (ruanyifeng.com)](https://es6.ruanyifeng.com/#docs/module-loader#ES6-模块与-CommonJS-模块的差异)



### 前端安全方面

`XSS`(`Cross-Site Scripting`，**跨站脚本攻击**)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 `cookie，session tokens`，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。

`CSRF`（`Cross-site request forgery`）**跨站请求伪造**：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

链接：https://juejin.cn/post/6989422484722286600


- XSS跨站脚本预防：把尖括号<>换成&lt和&gt
- XSRF跨站请求伪造预防：使用post接口，增加验证密码指纹短信验证



### 使用iframe的缺点

- iframe会阻塞主页面的onload事件

- iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

- iframe框架结构很迷惑，如果嵌套多个iframe页面的货出现多个滚动条，用户体验差；

- 代码复杂，不容易被搜索引擎搜索到，所以iframe不利于搜索引擎优化，很多搜索引擎爬虫还不能很好的处理iframe的内容；

- 很多移动设备无法完全显示框架，设备兼容性差；

- iframe框架页面会增加服务器的http请求，对于大型网站是不可取的
